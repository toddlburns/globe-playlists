<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crambe Repetita</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #00ff00;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        /* Scanline overlay for retro effect */
        #scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            z-index: 10;
        }

        /* CRT screen curve effect */
        #crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(
                ellipse at center,
                transparent 0%,
                transparent 70%,
                rgba(0, 0, 0, 0.4) 100%
            );
            z-index: 11;
        }

        #title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 8px;
            text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00;
            z-index: 20;
            text-align: center;
        }

        #title-subtitle {
            font-family: 'Pacifico', cursive;
            font-size: 14px;
            text-transform: none;
            letter-spacing: 2px;
            margin-top: 5px;
            opacity: 0.8;
        }

        #bottom-links {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            z-index: 20;
            text-align: center;
            display: flex;
            gap: 20px;
        }

        .bottom-link {
            opacity: 0.6;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        .bottom-link:hover {
            opacity: 1;
            text-shadow: 0 0 10px #00ff00;
        }

        .bottom-link a {
            color: #00ff00;
            text-decoration: none;
        }

        /* About modal */
        #about-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 200;
            display: none;
            justify-content: center;
            align-items: center;
        }

        #about-overlay.open {
            display: flex;
        }

        #about-box {
            background: rgba(0, 10, 0, 0.95);
            border: 2px solid #00ff00;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            position: relative;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.2);
        }

        #about-box h2 {
            font-size: 20px;
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 25px;
            text-shadow: 0 0 10px #00ff00;
            text-align: center;
        }

        #about-content {
            font-size: 14px;
            line-height: 1.8;
            min-height: 150px;
        }

        #about-cursor {
            display: inline-block;
            width: 10px;
            height: 16px;
            background: #00ff00;
            margin-left: 2px;
            animation: blink 0.7s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        #close-about {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: 1px solid #00ff00;
            color: #00ff00;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 16px;
        }

        #close-about:hover {
            background: #00ff00;
            color: #0a0a0a;
        }

        #about-content a {
            color: #00ff00;
            text-decoration: none;
        }

        #about-content a:hover {
            text-shadow: 0 0 10px #00ff00;
        }

        /* Playlist panel */
        #playlist-panel {
            position: fixed;
            right: -420px;
            top: 0;
            width: 400px;
            height: 100%;
            background: rgba(0, 10, 0, 0.95);
            border-left: 2px solid #00ff00;
            transition: right 0.3s ease;
            z-index: 100;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        #playlist-panel.open {
            right: 0;
        }

        #playlist-panel h2 {
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ff00;
            font-size: 18px;
        }

        #playlist-panel .location {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 20px;
        }

        #close-panel {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: 1px solid #00ff00;
            color: #00ff00;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 16px;
        }

        #close-panel:hover {
            background: #00ff00;
            color: #0a0a0a;
        }

        #spotify-embed {
            flex: 1;
            border: 1px solid #00ff00;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #spotify-embed iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        #spotify-embed.has-button {
            background: rgba(0, 20, 0, 0.5);
        }

        .spotify-flame-btn {
            position: relative;
            padding: 20px 40px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #00ff00;
            background: transparent;
            border: 2px solid #00ff00;
            cursor: pointer;
            overflow: visible;
            transition: all 0.3s ease;
        }

        .spotify-flame-btn::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 10%;
            right: 10%;
            height: 20px;
            background: linear-gradient(to top,
                rgba(0, 255, 0, 0.4) 0%,
                rgba(0, 200, 0, 0.2) 40%,
                rgba(0, 150, 0, 0.1) 70%,
                transparent 100%
            );
            filter: blur(3px);
            animation: flame-flicker 0.15s ease-in-out infinite alternate;
            pointer-events: none;
        }

        .spotify-flame-btn::after {
            content: '';
            position: absolute;
            top: -15px;
            left: 20%;
            right: 20%;
            height: 25px;
            background: linear-gradient(to top,
                rgba(100, 255, 100, 0.3) 0%,
                rgba(50, 200, 50, 0.15) 50%,
                transparent 100%
            );
            filter: blur(5px);
            animation: flame-flicker 0.2s ease-in-out infinite alternate-reverse;
            pointer-events: none;
        }

        @keyframes flame-flicker {
            0% {
                transform: scaleY(1) scaleX(1);
                opacity: 0.7;
            }
            50% {
                transform: scaleY(1.1) scaleX(0.95);
                opacity: 0.9;
            }
            100% {
                transform: scaleY(0.9) scaleX(1.05);
                opacity: 0.6;
            }
        }

        .spotify-flame-btn:hover {
            background: rgba(0, 255, 0, 0.1);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3),
                        0 0 40px rgba(0, 255, 0, 0.2);
            text-shadow: 0 0 10px #00ff00;
        }

        .spotify-flame-btn:hover::before,
        .spotify-flame-btn:hover::after {
            animation-duration: 0.1s;
        }

        /* City browser modal for hotspots */
        #city-browser-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 150;
            display: none;
            justify-content: center;
            align-items: center;
        }

        #city-browser-overlay.open {
            display: flex;
        }

        #city-browser-box {
            background: rgba(0, 10, 0, 0.95);
            border: 2px solid #00ff00;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            position: relative;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.2);
        }

        #city-browser-box h2 {
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ff00;
            text-align: center;
        }

        #city-browser-list {
            max-height: 50vh;
            overflow-y: auto;
        }

        #city-browser-list::-webkit-scrollbar {
            width: 6px;
        }

        #city-browser-list::-webkit-scrollbar-track {
            background: rgba(0, 10, 0, 0.5);
        }

        #city-browser-list::-webkit-scrollbar-thumb {
            background: #00ff00;
            border-radius: 3px;
        }

        .city-playlist-item {
            padding: 12px 15px;
            border: 1px solid rgba(0, 255, 0, 0.3);
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .city-playlist-item:hover {
            background: rgba(0, 255, 0, 0.1);
            border-color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
        }

        .city-playlist-count {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 15px;
            text-align: center;
        }

        #close-city-browser {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: 1px solid #00ff00;
            color: #00ff00;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 16px;
        }

        #close-city-browser:hover {
            background: #00ff00;
            color: #0a0a0a;
        }

        /* Tooltip for hover */
        #tooltip {
            position: fixed;
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #00ff00;
            padding: 8px 12px;
            font-size: 12px;
            pointer-events: none;
            z-index: 50;
            display: none;
            text-shadow: 0 0 5px #00ff00;
        }

        /* Glow effect for points */
        .point-label {
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }

        /* Search container */
        #search-container {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            width: 300px;
        }

        #search-input {
            width: 100%;
            padding: 10px 15px;
            background: rgba(0, 10, 0, 0.8);
            border: 1px solid #00ff00;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #ff1493;
            text-shadow: 0 0 8px #ff1493;
            outline: none;
            caret-color: #ff1493;
        }

        #search-input::placeholder {
            color: #00ff00;
            opacity: 0.5;
            text-shadow: none;
        }

        #search-input:focus {
            border-color: #ff1493;
            box-shadow: 0 0 10px rgba(255, 20, 147, 0.3);
        }

        #search-dropdown {
            position: absolute;
            bottom: 100%;
            left: 0;
            width: 100%;
            max-height: 300px;
            overflow-y: auto;
            background: rgba(0, 10, 0, 0.95);
            border: 1px solid #00ff00;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            display: none;
        }

        #search-dropdown.open {
            display: block;
        }

        .search-option {
            padding: 10px 15px;
            cursor: pointer;
            font-size: 13px;
            color: #b06080;
            border-bottom: 1px solid rgba(255, 20, 147, 0.1);
            transition: background 0.15s ease;
        }

        .search-option:hover {
            background: rgba(255, 20, 147, 0.1);
            color: #d080a0;
        }

        .search-option .location-hint {
            font-size: 11px;
            color: #804060;
            margin-top: 2px;
        }

        #search-dropdown::-webkit-scrollbar {
            width: 6px;
        }

        #search-dropdown::-webkit-scrollbar-track {
            background: rgba(0, 10, 0, 0.5);
        }

        #search-dropdown::-webkit-scrollbar-thumb {
            background: #00ff00;
            border-radius: 3px;
        }

        /* Intro animation */
        #intro-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.85);
            z-index: 500;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 1;
            transition: opacity 0.8s ease;
            pointer-events: all;
        }

        #intro-overlay.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        #intro-overlay.hidden {
            display: none;
        }

        #intro-text {
            font-family: 'Pacifico', cursive;
            font-size: 48px;
            font-weight: normal;
            letter-spacing: 4px;
            text-transform: none;
            color: #00ff00;
            text-shadow:
                0 0 5px #00ff00,
                0 0 10px #00ff00,
                0 0 20px #00ff00,
                0 0 40px #00ff00,
                0 0 80px #003300;
            opacity: 0;
            white-space: nowrap;
            display: flex;
            align-items: center;
        }

        #intro-text .final-a {
            display: inline-block;
            transition: none;
        }

        #intro-text .final-a.fly-out {
            animation: flyOutCorner 0.8s ease-in forwards;
        }

        @keyframes flyOutCorner {
            0% {
                transform: translate(0, 0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translate(calc(50vw), calc(-50vh)) rotate(45deg);
                opacity: 1;
            }
        }

        @media (max-width: 768px) {
            #intro-text {
                font-size: 24px;
                letter-spacing: 2px;
            }
        }

        @media (max-width: 480px) {
            #intro-text {
                font-size: 18px;
                letter-spacing: 1px;
            }
        }

        @keyframes neon-pulse {
            0% {
                text-shadow:
                    0 0 5px #00ff00,
                    0 0 10px #00ff00,
                    0 0 20px #00ff00,
                    0 0 40px #00ff00,
                    0 0 80px #003300;
            }
            100% {
                text-shadow:
                    0 0 10px #00ff00,
                    0 0 20px #00ff00,
                    0 0 40px #00ff00,
                    0 0 60px #00ff00,
                    0 0 100px #003300;
            }
        }

        @keyframes flicker-in {
            0% { opacity: 0; }
            10% { opacity: 0.6; }
            20% { opacity: 0.2; }
            30% { opacity: 0.8; }
            40% { opacity: 0.3; }
            50% { opacity: 0.9; }
            60% { opacity: 0.5; }
            70% { opacity: 1; }
            80% { opacity: 0.7; }
            90% { opacity: 0.95; }
            100% { opacity: 1; }
        }

        @keyframes flicker-out {
            0% { opacity: 1; }
            5% { opacity: 0.9; }
            10% { opacity: 1; }
            15% { opacity: 0.7; }
            20% { opacity: 0.9; }
            30% { opacity: 0.4; }
            35% { opacity: 0.7; }
            40% { opacity: 0.3; }
            50% { opacity: 0.6; }
            55% { opacity: 0.2; }
            60% { opacity: 0.5; }
            70% { opacity: 0.1; }
            75% { opacity: 0.3; }
            80% { opacity: 0.05; }
            85% { opacity: 0.2; }
            90% { opacity: 0.02; }
            95% { opacity: 0.1; }
            100% { opacity: 0; }
        }

        #intro-text.flicker-in {
            animation: flicker-in 0.8s ease forwards, neon-pulse 2s ease-in-out infinite alternate;
        }

        #intro-text.flicker-out {
            animation: flicker-out 2s ease forwards;
        }

        @keyframes tv-on {
            0% {
                transform: scale(1, 0.02);
                filter: brightness(10);
            }
            50% {
                transform: scale(1, 0.02);
                filter: brightness(5);
            }
            70% {
                transform: scale(1, 1);
                filter: brightness(2);
            }
            100% {
                transform: scale(1, 1);
                filter: brightness(1);
            }
        }

        #intro-overlay.tv-on {
            animation: tv-on 0.6s ease-out forwards;
        }
    </style>
</head>
<body>
    <div id="intro-overlay">
        <div id="intro-text"></div>
    </div>
    <div id="container"></div>
    <div id="scanlines"></div>
    <div id="crt-overlay"></div>
    <div id="title">[ Crambe Repetita ]<div id="title-subtitle">Playlists</div></div>
    <div id="search-container">
        <input type="text" id="search-input" placeholder="Search playlists..." autocomplete="off">
        <div id="search-dropdown"></div>
    </div>
    <div id="bottom-links">
        <div class="bottom-link" id="about-link">[ About ]</div>
        <div class="bottom-link"><a href="https://toddlburns.github.io/crambe-repetita-hats/" target="_blank">[ Hats ]</a></div>
    </div>
    <div id="tooltip"></div>

    <div id="about-overlay">
        <div id="about-box">
            <button id="close-about">Ã—</button>
            <h2 id="about-title"></h2>
            <div id="about-content"><span id="about-cursor"></span></div>
        </div>
    </div>

    <div id="playlist-panel">
        <button id="close-panel">Ã—</button>
        <h2 id="panel-title">Playlist Name</h2>
        <div class="location" id="panel-location">Location</div>
        <div id="spotify-embed"></div>
    </div>

    <div id="city-browser-overlay">
        <div id="city-browser-box">
            <button id="close-city-browser">Ã—</button>
            <h2 id="city-browser-title">City Name</h2>
            <div id="city-browser-list"></div>
            <div class="city-playlist-count"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="playlists-data.js"></script>
    <script>
        let scene, camera, renderer, globe, points = [];
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationVelocity = { x: 0, y: 0 };
        let autoRotate = true;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const container = document.getElementById('container');
        const tooltip = document.getElementById('tooltip');
        const panel = document.getElementById('playlist-panel');
        const panelTitle = document.getElementById('panel-title');
        const panelLocation = document.getElementById('panel-location');
        const spotifyEmbed = document.getElementById('spotify-embed');

        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 2.5;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x0a0a0a);
            container.appendChild(renderer.domElement);

            createGlobe();
            createPlaylistPoints();
            addEventListeners();
            animate();
        }

        function createGlobe() {
            // Main wireframe sphere
            const geometry = new THREE.SphereGeometry(1, 32, 24);
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            globe = new THREE.Mesh(geometry, material);
            scene.add(globe);

            // Inner glow sphere
            const innerGeometry = new THREE.SphereGeometry(0.98, 16, 12);
            const innerMaterial = new THREE.MeshBasicMaterial({
                color: 0x003300,
                wireframe: true,
                transparent: true,
                opacity: 0.15
            });
            const innerSphere = new THREE.Mesh(innerGeometry, innerMaterial);
            globe.add(innerSphere);

            // Latitude lines (more visible)
            for (let i = -60; i <= 60; i += 30) {
                const latRadius = Math.cos(i * Math.PI / 180);
                const latY = Math.sin(i * Math.PI / 180);
                const latGeometry = new THREE.RingGeometry(latRadius - 0.002, latRadius + 0.002, 64);
                const latMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.5
                });
                const latRing = new THREE.Mesh(latGeometry, latMaterial);
                latRing.position.y = latY;
                latRing.rotation.x = Math.PI / 2;
                globe.add(latRing);
            }

            // Equator (brighter)
            const equatorGeometry = new THREE.RingGeometry(0.998, 1.002, 64);
            const equatorMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            const equator = new THREE.Mesh(equatorGeometry, equatorMaterial);
            equator.rotation.x = Math.PI / 2;
            globe.add(equator);

            // Prime meridian
            const meridianGeometry = new THREE.TorusGeometry(1, 0.003, 8, 64);
            const meridianMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.5
            });
            const meridian = new THREE.Mesh(meridianGeometry, meridianMaterial);
            globe.add(meridian);

            // Add some "ASCII" dots pattern on the surface
            const dotsGeometry = new THREE.BufferGeometry();
            const dotPositions = [];
            for (let i = 0; i < 500; i++) {
                const phi = Math.acos(-1 + (2 * i) / 500);
                const theta = Math.sqrt(500 * Math.PI) * phi;
                const x = Math.cos(theta) * Math.sin(phi);
                const y = Math.sin(theta) * Math.sin(phi);
                const z = Math.cos(phi);
                dotPositions.push(x * 1.01, y * 1.01, z * 1.01);
            }
            dotsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dotPositions, 3));
            const dotsMaterial = new THREE.PointsMaterial({
                color: 0x00ff00,
                size: 0.015,
                transparent: true,
                opacity: 0.4
            });
            const dots = new THREE.Points(dotsGeometry, dotsMaterial);
            globe.add(dots);
        }

        function latLngToVector3(lat, lng, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lng + 180) * (Math.PI / 180);
            const x = -radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);
            return new THREE.Vector3(x, y, z);
        }

        // Group playlists by location and identify hotspots
        let hotspots = {};
        let locationGroups = {};

        function groupPlaylistsByLocation() {
            playlists.forEach((playlist, index) => {
                const loc = playlist.location;
                if (!locationGroups[loc]) {
                    locationGroups[loc] = [];
                }
                locationGroups[loc].push({ playlist, index });
            });

            // Identify hotspots (10+ playlists)
            Object.keys(locationGroups).forEach(loc => {
                if (locationGroups[loc].length >= 10) {
                    hotspots[loc] = locationGroups[loc];
                }
            });
        }

        function createPlaylistPoints() {
            groupPlaylistsByLocation();

            const processedLocations = new Set();
            const minDistance = 0.04; // Minimum distance between dots

            playlists.forEach((playlist, index) => {
                const loc = playlist.location;

                // Check if this is a hotspot location
                if (hotspots[loc]) {
                    // Only create one point per hotspot
                    if (processedLocations.has(loc)) return;
                    processedLocations.add(loc);

                    // Calculate average position for the hotspot
                    let avgLat = 0, avgLng = 0;
                    hotspots[loc].forEach(item => {
                        avgLat += item.playlist.lat;
                        avgLng += item.playlist.lng;
                    });
                    avgLat /= hotspots[loc].length;
                    avgLng /= hotspots[loc].length;

                    const position = latLngToVector3(avgLat, avgLng, 1.02);

                    // Create larger hotspot point with flame effect layers
                    const hotspotGroup = new THREE.Group();

                    // Core point (larger)
                    const coreGeometry = new THREE.SphereGeometry(0.025, 16, 16);
                    const coreMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ff00,
                        transparent: true,
                        opacity: 0.9
                    });
                    const core = new THREE.Mesh(coreGeometry, coreMaterial);
                    hotspotGroup.add(core);

                    // Inner flame glow
                    const innerFlameGeometry = new THREE.SphereGeometry(0.035, 12, 12);
                    const innerFlameMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00cc00,
                        transparent: true,
                        opacity: 0.4
                    });
                    const innerFlame = new THREE.Mesh(innerFlameGeometry, innerFlameMaterial);
                    hotspotGroup.add(innerFlame);

                    // Outer flame glow
                    const outerFlameGeometry = new THREE.SphereGeometry(0.045, 10, 10);
                    const outerFlameMaterial = new THREE.MeshBasicMaterial({
                        color: 0x009900,
                        transparent: true,
                        opacity: 0.2
                    });
                    const outerFlame = new THREE.Mesh(outerFlameGeometry, outerFlameMaterial);
                    hotspotGroup.add(outerFlame);

                    hotspotGroup.position.copy(position);
                    hotspotGroup.userData = {
                        isHotspot: true,
                        location: loc,
                        playlists: hotspots[loc],
                        baseLat: avgLat,
                        baseLng: avgLng
                    };

                    globe.add(hotspotGroup);
                    points.push({ point: hotspotGroup, playlist: null, isHotspot: true, location: loc });
                } else {
                    // Regular point - check for spacing
                    let position = latLngToVector3(playlist.lat, playlist.lng, 1.02);

                    // Check distance from existing points and adjust if too close
                    let attempts = 0;
                    let offset = 0;
                    while (attempts < 8) {
                        let tooClose = false;
                        for (const p of points) {
                            const dist = position.distanceTo(p.point.position);
                            if (dist < minDistance) {
                                tooClose = true;
                                break;
                            }
                        }
                        if (!tooClose) break;

                        // Offset the position slightly
                        attempts++;
                        offset += 0.8;
                        const offsetLat = playlist.lat + (Math.sin(attempts * 1.5) * offset);
                        const offsetLng = playlist.lng + (Math.cos(attempts * 1.5) * offset);
                        position = latLngToVector3(offsetLat, offsetLng, 1.02);
                    }

                    // Glowing point
                    const pointGeometry = new THREE.SphereGeometry(0.012, 12, 12);
                    const pointMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00ff00,
                        transparent: true,
                        opacity: 0.9
                    });
                    const point = new THREE.Mesh(pointGeometry, pointMaterial);
                    point.position.copy(position);
                    point.userData = { playlist, index, isHotspot: false };

                    globe.add(point);
                    points.push({ point, playlist, isHotspot: false });
                }
            });
        }

        function addEventListeners() {
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mouseleave', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);
            renderer.domElement.addEventListener('click', onClick);
            renderer.domElement.addEventListener('dblclick', onDoubleClick);
            window.addEventListener('resize', onWindowResize);
            document.getElementById('close-panel').addEventListener('click', closePanel);
        }

        function onMouseDown(event) {
            isDragging = true;
            autoRotate = false;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Check for hover on points (including hotspot children)
            raycaster.setFromCamera(mouse, camera);

            const hoverableObjects = [];
            points.forEach(p => {
                if (p.isHotspot) {
                    p.point.children.forEach(child => {
                        child.userData.parentPoint = p;
                        hoverableObjects.push(child);
                    });
                } else {
                    p.point.userData.parentPoint = p;
                    hoverableObjects.push(p.point);
                }
            });

            const intersects = raycaster.intersectObjects(hoverableObjects);

            // Only consider points on the front side of the globe
            const globeDistance = camera.position.z;
            const frontIntersects = intersects.filter(i => i.distance < globeDistance);

            if (frontIntersects.length > 0) {
                // Sort by distance and get the closest one
                frontIntersects.sort((a, b) => a.distance - b.distance);
                const parentPoint = frontIntersects[0].object.userData.parentPoint;

                tooltip.style.display = 'block';
                tooltip.style.left = event.clientX + 15 + 'px';
                tooltip.style.top = event.clientY + 15 + 'px';

                if (parentPoint.isHotspot) {
                    const count = hotspots[parentPoint.location].length;
                    tooltip.innerHTML = `ðŸ”¥ ${parentPoint.location}<br><span style="opacity:0.6">${count} playlists - click to browse</span>`;
                } else {
                    const playlist = parentPoint.playlist;
                    tooltip.innerHTML = `â–º ${playlist.name}<br><span style="opacity:0.6">${playlist.location}</span>`;
                }
                renderer.domElement.style.cursor = 'pointer';
            } else {
                tooltip.style.display = 'none';
                renderer.domElement.style.cursor = isDragging ? 'grabbing' : 'grab';
            }

            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                rotationVelocity.x = deltaY * 0.005;
                rotationVelocity.y = deltaX * 0.005;

                globe.rotation.x += rotationVelocity.x;
                globe.rotation.y += rotationVelocity.y;

                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }

        function onMouseUp() {
            isDragging = false;
            renderer.domElement.style.cursor = 'grab';
        }

        function onWheel(event) {
            event.preventDefault();
            camera.position.z += event.deltaY * 0.001;
            camera.position.z = Math.max(1.5, Math.min(5, camera.position.z));
        }

        function onClick(event) {
            // Stop rotation on any click
            autoRotate = false;
            rotationVelocity = { x: 0, y: 0 };

            raycaster.setFromCamera(mouse, camera);

            // Get all clickable objects (including children of groups for hotspots)
            const clickableObjects = [];
            points.forEach(p => {
                if (p.isHotspot) {
                    // For hotspots (groups), add children to check
                    p.point.children.forEach(child => {
                        child.userData.parentPoint = p;
                        clickableObjects.push(child);
                    });
                } else {
                    p.point.userData.parentPoint = p;
                    clickableObjects.push(p.point);
                }
            });

            const intersects = raycaster.intersectObjects(clickableObjects);

            if (intersects.length > 0) {
                // Sort by distance and get the closest one
                intersects.sort((a, b) => a.distance - b.distance);

                // Only select points on the front side of the globe (closer than globe center)
                const globeDistance = camera.position.z;
                const closest = intersects.find(i => i.distance < globeDistance);

                if (closest) {
                    const parentPoint = closest.object.userData.parentPoint;

                    if (parentPoint.isHotspot) {
                        // Open city browser for hotspot
                        openCityBrowser(parentPoint.location);
                    } else {
                        // Open regular playlist
                        openPlaylist(parentPoint.playlist);
                    }
                }
            }
        }

        function onDoubleClick(event) {
            // Resume rotation on double click
            autoRotate = true;
        }

        let currentPlaylistId = null;

        function openPlaylist(playlist) {
            panelTitle.textContent = playlist.name;
            panelLocation.textContent = playlist.location;
            currentPlaylistId = playlist.spotifyId;

            // Show flaming button instead of embed
            spotifyEmbed.classList.add('has-button');
            spotifyEmbed.innerHTML = `
                <button class="spotify-flame-btn" onclick="loadSpotifyEmbed()">
                    â–º Open Player
                </button>
            `;
            panel.classList.add('open');
        }

        function loadSpotifyEmbed() {
            if (!currentPlaylistId) return;
            spotifyEmbed.classList.remove('has-button');
            spotifyEmbed.innerHTML = `
                <iframe
                    style="border-radius:12px"
                    src="https://open.spotify.com/embed/playlist/${currentPlaylistId}?utm_source=generator&theme=0"
                    width="100%"
                    height="100%"
                    frameBorder="0"
                    allowfullscreen=""
                    allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"
                    loading="lazy">
                </iframe>
            `;
        }

        function closePanel() {
            panel.classList.remove('open');
            spotifyEmbed.innerHTML = '';
        }

        // City browser for hotspots
        const cityBrowserOverlay = document.getElementById('city-browser-overlay');
        const cityBrowserTitle = document.getElementById('city-browser-title');
        const cityBrowserList = document.getElementById('city-browser-list');
        const closeCityBrowser = document.getElementById('close-city-browser');

        function openCityBrowser(location) {
            const cityPlaylists = hotspots[location];
            if (!cityPlaylists) return;

            cityBrowserTitle.textContent = location;

            cityBrowserList.innerHTML = cityPlaylists.map((item, i) => `
                <div class="city-playlist-item" data-index="${item.index}">
                    â–º ${item.playlist.name}
                </div>
            `).join('');

            document.querySelector('.city-playlist-count').textContent =
                `${cityPlaylists.length} playlists`;

            cityBrowserOverlay.classList.add('open');
        }

        function closeCityBrowserPanel() {
            cityBrowserOverlay.classList.remove('open');
        }

        closeCityBrowser.addEventListener('click', closeCityBrowserPanel);
        cityBrowserOverlay.addEventListener('click', function(e) {
            if (e.target === cityBrowserOverlay) {
                closeCityBrowserPanel();
            }
        });

        cityBrowserList.addEventListener('click', function(e) {
            const item = e.target.closest('.city-playlist-item');
            if (item) {
                const index = parseInt(item.dataset.index);
                const playlist = playlists[index];
                closeCityBrowserPanel();
                openPlaylist(playlist);
            }
        });

        // Search functionality
        const searchInput = document.getElementById('search-input');
        const searchDropdown = document.getElementById('search-dropdown');
        let isSpinning = false;

        searchInput.addEventListener('input', function() {
            const query = this.value.toLowerCase().trim();

            if (query.length < 1) {
                searchDropdown.classList.remove('open');
                return;
            }

            const matches = playlists.filter(p =>
                p.name.toLowerCase().includes(query) ||
                p.location.toLowerCase().includes(query)
            ).slice(0, 10);

            if (matches.length > 0) {
                searchDropdown.innerHTML = matches.map((p, i) => `
                    <div class="search-option" data-index="${playlists.indexOf(p)}">
                        ${p.name}
                        <div class="location-hint">${p.location}</div>
                    </div>
                `).join('');
                searchDropdown.classList.add('open');
            } else {
                searchDropdown.classList.remove('open');
            }
        });

        searchInput.addEventListener('focus', function() {
            if (this.value.length >= 1) {
                searchInput.dispatchEvent(new Event('input'));
            }
        });

        document.addEventListener('click', function(e) {
            if (!e.target.closest('#search-container')) {
                searchDropdown.classList.remove('open');
            }
        });

        searchDropdown.addEventListener('click', function(e) {
            const option = e.target.closest('.search-option');
            if (option) {
                const index = parseInt(option.dataset.index);
                const playlist = playlists[index];
                searchInput.value = '';
                searchDropdown.classList.remove('open');
                spinToPlaylist(playlist);
            }
        });

        function spinToPlaylist(playlist) {
            if (isSpinning) return;
            isSpinning = true;
            autoRotate = false;
            rotationVelocity = { x: 0, y: 0 };

            const targetPosition = latLngToVector3(playlist.lat, playlist.lng, 1.02);

            // Calculate target rotation to face the point
            const targetLng = playlist.lng;
            const targetLat = playlist.lat;

            // Target Y rotation (longitude) - add 180 to face the point
            const targetRotY = -((targetLng + 180) * Math.PI / 180) + Math.PI;
            // Target X rotation (latitude)
            const targetRotX = (targetLat * Math.PI / 180);

            // Current rotation
            const startRotX = globe.rotation.x;
            const startRotY = globe.rotation.y;

            // Normalize current Y rotation
            let normalizedStartY = startRotY % (2 * Math.PI);

            // Calculate the shortest path for Y rotation
            let deltaY = targetRotY - normalizedStartY;

            // Add extra spins for dramatic effect (2 full rotations + shortest path)
            const extraSpins = 2 * 2 * Math.PI;
            if (deltaY > 0) {
                deltaY += extraSpins;
            } else {
                deltaY -= extraSpins;
            }

            const finalRotY = startRotY + deltaY;
            const duration = 1500; // 1.5 seconds
            const startTime = Date.now();

            function animateSpin() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Easing function: easeOutExpo for fast start, smooth end
                const eased = progress === 1 ? 1 : 1 - Math.pow(2, -10 * progress);

                globe.rotation.x = startRotX + (targetRotX - startRotX) * eased;
                globe.rotation.y = startRotY + (finalRotY - startRotY) * eased;

                if (progress < 1) {
                    requestAnimationFrame(animateSpin);
                } else {
                    isSpinning = false;
                    openPlaylist(playlist);
                }
            }

            animateSpin();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Colors for front and back points
        const frontColor = new THREE.Color(0x00ff00); // Bright green
        const backColor = new THREE.Color(0x006666);  // Muted teal for back-side points
        const hotspotFrontColors = [
            new THREE.Color(0x00ff00),
            new THREE.Color(0x00cc00),
            new THREE.Color(0x009900)
        ];
        const hotspotBackColors = [
            new THREE.Color(0x006666),
            new THREE.Color(0x005555),
            new THREE.Color(0x004444)
        ];

        let animationTime = 0;

        function animate() {
            requestAnimationFrame(animate);
            animationTime += 0.05;

            // Auto rotation when not dragging
            if (autoRotate) {
                globe.rotation.y += 0.0005;
            } else {
                // Momentum after dragging
                if (!isDragging) {
                    rotationVelocity.x *= 0.95;
                    rotationVelocity.y *= 0.95;
                    globe.rotation.x += rotationVelocity.x;
                    globe.rotation.y += rotationVelocity.y;
                }
            }

            // Update point colors based on whether they're facing the camera
            const cameraPosition = camera.position.clone();
            points.forEach(({ point, isHotspot }) => {
                // Get world position of the point
                const worldPos = new THREE.Vector3();
                point.getWorldPosition(worldPos);

                // Check if point is on the front side (facing camera)
                const toCamera = cameraPosition.clone().sub(worldPos).normalize();
                const pointNormal = worldPos.clone().normalize();
                const dotProduct = toCamera.dot(pointNormal);
                const isFront = dotProduct > 0.1;

                if (isHotspot) {
                    // Animate hotspot children with flaming effect
                    const flameIntensity = 0.5 + 0.5 * Math.sin(animationTime * 2);
                    const flameScale = 1 + 0.15 * Math.sin(animationTime * 3);

                    point.children.forEach((child, idx) => {
                        if (isFront) {
                            child.material.color.copy(hotspotFrontColors[idx] || hotspotFrontColors[0]);
                            if (idx === 0) {
                                child.material.opacity = 0.9;
                            } else if (idx === 1) {
                                child.material.opacity = 0.3 + 0.2 * flameIntensity;
                                child.scale.setScalar(flameScale);
                            } else {
                                child.material.opacity = 0.15 + 0.15 * flameIntensity;
                                child.scale.setScalar(flameScale * 1.1);
                            }
                        } else {
                            child.material.color.copy(hotspotBackColors[idx] || hotspotBackColors[0]);
                            child.material.opacity = idx === 0 ? 0.4 : 0.1;
                            child.scale.setScalar(1);
                        }
                    });
                } else {
                    // Regular point
                    if (isFront) {
                        point.material.color.copy(frontColor);
                        point.material.opacity = 0.9;
                    } else {
                        point.material.color.copy(backColor);
                        point.material.opacity = 0.4;
                    }
                }
            });

            renderer.render(scene, camera);
        }

        // About page typewriter effect
        const aboutLink = document.getElementById('about-link');
        const aboutOverlay = document.getElementById('about-overlay');
        const aboutTitle = document.getElementById('about-title');
        const aboutContent = document.getElementById('about-content');
        const closeAbout = document.getElementById('close-about');

        const aboutTitleText = 'crambe repetita';
        const aboutBodyText = `Hi!<br><br>Thanks for coming by my playlist website. My name is Todd L. Burns and I love music! If you're anything like me, you probably like to dig for music. To find that next great song, album, mix, or whatever.<br><br>Well, I've created this fun little website to share some of my own finds from around the world. I hope you enjoy my music taste just as much as I do!<br><br>If you ever want to chat about music, you can reach me at <a href="mailto:todd.burns@gmail.com">todd.burns@gmail.com</a>.<br><br>Have a blessed day!`;

        let typewriterTimeout;
        let isTyping = false;
        let aboutDisappearTimeout;
        let aboutDisappearInterval;
        let hasDisappeared = false;

        function typeWriter(element, text, index, callback) {
            if (index < text.length) {
                // Handle HTML tags (including self-closing like <br>)
                if (text[index] === '<') {
                    const tagEnd = text.indexOf('>', index);
                    if (tagEnd !== -1) {
                        // Check if it's a self-closing tag like <br>
                        const tagContent = text.substring(index, tagEnd + 1);
                        if (tagContent.match(/^<br\s*\/?>$/i)) {
                            element.innerHTML = text.substring(0, tagEnd + 1) + '<span id="about-cursor"></span>';
                            typewriterTimeout = setTimeout(() => typeWriter(element, text, tagEnd + 1, callback), 30);
                            return;
                        }
                        // Handle opening tags with closing tags (like <a>...</a>)
                        const closingTagStart = text.indexOf('</', tagEnd);
                        const closingTagEnd = text.indexOf('>', closingTagStart);
                        if (closingTagStart !== -1 && closingTagEnd !== -1) {
                            const fullTag = text.substring(index, closingTagEnd + 1);
                            element.innerHTML = text.substring(0, closingTagEnd + 1) + '<span id="about-cursor"></span>';
                            typewriterTimeout = setTimeout(() => typeWriter(element, text, closingTagEnd + 1, callback), 30);
                            return;
                        }
                    }
                }

                element.innerHTML = text.substring(0, index + 1) + '<span id="about-cursor"></span>';

                // Check if we just typed a sentence-ending punctuation
                const char = text[index];
                const nextChar = text[index + 1];
                const isSentenceEnd = (char === '.' || char === '!' || char === '?') && (nextChar === ' ' || nextChar === '<');

                let delay = 25; // Fast typing
                if (isSentenceEnd) {
                    delay = 1200; // Pause at end of sentence
                }

                typewriterTimeout = setTimeout(() => typeWriter(element, text, index + 1, callback), delay);
            } else {
                element.innerHTML = text + '<span id="about-cursor"></span>';
                if (callback) callback();
            }
        }

        function startAboutAnimation() {
            aboutTitle.textContent = '';
            aboutContent.innerHTML = '<span id="about-cursor"></span>';
            isTyping = true;

            // Type title first
            let titleIndex = 0;
            function typeTitle() {
                if (titleIndex < aboutTitleText.length) {
                    aboutTitle.textContent = aboutTitleText.substring(0, titleIndex + 1);
                    titleIndex++;
                    typewriterTimeout = setTimeout(typeTitle, 50);
                } else {
                    // Then type body
                    setTimeout(() => {
                        typeWriter(aboutContent, aboutBodyText, 0, () => {
                            isTyping = false;
                        });
                    }, 500);
                }
            }
            typeTitle();
        }

        function openAbout() {
            aboutOverlay.classList.add('open');
            hasDisappeared = false;
            startAboutAnimation();

            // Start 30 second timer for disappearing effect
            clearTimeout(aboutDisappearTimeout);
            clearInterval(aboutDisappearInterval);
            aboutDisappearTimeout = setTimeout(() => {
                if (aboutOverlay.classList.contains('open') && !isTyping) {
                    startDisappearingEffect();
                }
            }, 30000);
        }

        function startDisappearingEffect() {
            hasDisappeared = true;
            const contentEl = aboutContent;
            const titleEl = aboutTitle;

            // Get all text content (visible letters only)
            let allText = titleEl.textContent + contentEl.innerText;
            let titleChars = titleEl.textContent.split('');
            let contentHtml = contentEl.innerHTML;

            // Remove cursor first
            contentHtml = contentHtml.replace(/<span id="about-cursor"><\/span>/g, '');

            // Wrap each letter in a span for individual removal
            let letterIndex = 0;
            titleEl.innerHTML = titleChars.map((char, i) =>
                char === ' ' ? ' ' : `<span class="about-letter" data-index="${letterIndex++}">${char}</span>`
            ).join('');

            // Process content - wrap letters but preserve HTML tags
            let processedContent = '';
            let inTag = false;
            for (let i = 0; i < contentHtml.length; i++) {
                const char = contentHtml[i];
                if (char === '<') {
                    inTag = true;
                    processedContent += char;
                } else if (char === '>') {
                    inTag = false;
                    processedContent += char;
                } else if (inTag || char === ' ' || char === '\n') {
                    processedContent += char;
                } else {
                    processedContent += `<span class="about-letter" data-index="${letterIndex++}">${char}</span>`;
                }
            }
            contentEl.innerHTML = processedContent;

            // Get all letter spans
            const allLetters = document.querySelectorAll('.about-letter');
            const letterArray = Array.from(allLetters);

            // Remove 3 letters per second (one every 333ms)
            aboutDisappearInterval = setInterval(() => {
                if (letterArray.length === 0) {
                    clearInterval(aboutDisappearInterval);
                    // Show the surprise messages
                    setTimeout(() => showSurpriseMessages(), 500);
                    return;
                }

                // Remove 3 random letters
                for (let i = 0; i < 3 && letterArray.length > 0; i++) {
                    const randomIndex = Math.floor(Math.random() * letterArray.length);
                    const letter = letterArray.splice(randomIndex, 1)[0];
                    if (letter) {
                        letter.style.opacity = '0';
                        letter.style.transition = 'opacity 0.2s';
                        setTimeout(() => letter.remove(), 200);
                    }
                }
            }, 333);
        }

        function showSurpriseMessages() {
            aboutTitle.innerHTML = '';
            aboutContent.innerHTML = '';

            const messages = [
                { text: 'I bet you thought something strange was going to happen now. Nope.', delay: 0 },
                { text: ' Sorry!', delay: 5000 },
                { text: ' It is what it is.', delay: 10000 }
            ];

            let currentText = '';

            function typeMessage(msgIndex, charIndex) {
                if (msgIndex >= messages.length) return;

                const msg = messages[msgIndex];
                if (charIndex === 0 && msgIndex > 0) {
                    // Pause before next message
                    setTimeout(() => typeMessage(msgIndex, charIndex), 5000);
                    return;
                }

                if (charIndex < msg.text.length) {
                    currentText += msg.text[charIndex];
                    aboutContent.innerHTML = currentText + '<span id="about-cursor"></span>';
                    setTimeout(() => typeMessage(msgIndex, charIndex + 1), 50);
                } else {
                    // Move to next message
                    setTimeout(() => typeMessage(msgIndex + 1, 0), 0);
                }
            }

            typeMessage(0, 0);
        }

        function closeAboutPanel() {
            aboutOverlay.classList.remove('open');
            clearTimeout(typewriterTimeout);
            clearTimeout(aboutDisappearTimeout);
            clearInterval(aboutDisappearInterval);
            isTyping = false;
        }

        aboutLink.addEventListener('click', openAbout);
        closeAbout.addEventListener('click', closeAboutPanel);
        aboutOverlay.addEventListener('click', function(e) {
            if (e.target === aboutOverlay) {
                closeAboutPanel();
            }
        });

        // Intro animation
        const introOverlay = document.getElementById('intro-overlay');
        const introText = document.getElementById('intro-text');
        const introTitle = 'crambe repetita';

        function playIntro() {
            // TV turning on effect
            setTimeout(() => {
                introOverlay.classList.add('tv-on');
            }, 100);

            // Start typing after TV on effect
            setTimeout(() => {
                typeIntroText(0);
            }, 800);
        }

        function typeIntroText(index) {
            if (index <= introTitle.length) {
                // Check if this is the final 'a'
                if (index === introTitle.length) {
                    // Wrap the final 'a' in a span for animation
                    const beforeA = introTitle.substring(0, index - 1);
                    introText.innerHTML = beforeA + '<span class="final-a">a</span>';
                } else {
                    introText.textContent = introTitle.substring(0, index);
                }
                if (index === 1) {
                    introText.classList.add('flicker-in');
                }
                setTimeout(() => typeIntroText(index + 1), 180);
            } else {
                // Text fully typed, wait then animate the final 'a' flying out
                setTimeout(() => {
                    const finalA = introText.querySelector('.final-a');
                    if (finalA) {
                        finalA.classList.add('fly-out');
                    }

                    // After 'a' flies out, flicker out the rest
                    setTimeout(() => {
                        introText.classList.remove('flicker-in');
                        introText.classList.add('flicker-out');

                        // Fade out overlay after text flickers out
                        setTimeout(() => {
                            introOverlay.classList.add('fade-out');

                            // Remove from DOM after fade
                            setTimeout(() => {
                                introOverlay.classList.add('hidden');
                            }, 800);
                        }, 2000);
                    }, 800);
                }, 1500);
            }
        }

        // Start intro, then init
        playIntro();
        init();
    </script>
</body>
</html>
