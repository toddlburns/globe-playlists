<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crambe Repetita</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #00ff00;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        /* Scanline overlay for retro effect */
        #scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            z-index: 10;
        }

        /* CRT screen curve effect */
        #crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(
                ellipse at center,
                transparent 0%,
                transparent 70%,
                rgba(0, 0, 0, 0.4) 100%
            );
            z-index: 11;
        }

        #title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 8px;
            text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00;
            z-index: 20;
        }

        #instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            opacity: 0.6;
            z-index: 20;
            text-align: center;
        }

        /* Playlist panel */
        #playlist-panel {
            position: fixed;
            right: -420px;
            top: 0;
            width: 400px;
            height: 100%;
            background: rgba(0, 10, 0, 0.95);
            border-left: 2px solid #00ff00;
            transition: right 0.3s ease;
            z-index: 100;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        #playlist-panel.open {
            right: 0;
        }

        #playlist-panel h2 {
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ff00;
            font-size: 18px;
        }

        #playlist-panel .location {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 20px;
        }

        #close-panel {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: 1px solid #00ff00;
            color: #00ff00;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 16px;
        }

        #close-panel:hover {
            background: #00ff00;
            color: #0a0a0a;
        }

        #spotify-embed {
            flex: 1;
            border: 1px solid #00ff00;
            border-radius: 8px;
            overflow: hidden;
        }

        #spotify-embed iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Tooltip for hover */
        #tooltip {
            position: fixed;
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #00ff00;
            padding: 8px 12px;
            font-size: 12px;
            pointer-events: none;
            z-index: 50;
            display: none;
            text-shadow: 0 0 5px #00ff00;
        }

        /* Glow effect for points */
        .point-label {
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="scanlines"></div>
    <div id="crt-overlay"></div>
    <div id="title">[ Crambe Repetita ]</div>
    <div id="instructions">Drag to rotate • Scroll to zoom • Click points to play</div>
    <div id="tooltip"></div>

    <div id="playlist-panel">
        <button id="close-panel">×</button>
        <h2 id="panel-title">Playlist Name</h2>
        <div class="location" id="panel-location">Location</div>
        <div id="spotify-embed"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="playlists-data.js"></script>
    <script>
        let scene, camera, renderer, globe, points = [];
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationVelocity = { x: 0, y: 0 };
        let autoRotate = true;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const container = document.getElementById('container');
        const tooltip = document.getElementById('tooltip');
        const panel = document.getElementById('playlist-panel');
        const panelTitle = document.getElementById('panel-title');
        const panelLocation = document.getElementById('panel-location');
        const spotifyEmbed = document.getElementById('spotify-embed');

        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 2.5;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x0a0a0a);
            container.appendChild(renderer.domElement);

            createGlobe();
            createPlaylistPoints();
            addEventListeners();
            animate();
        }

        function createGlobe() {
            // Main wireframe sphere
            const geometry = new THREE.SphereGeometry(1, 32, 24);
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            globe = new THREE.Mesh(geometry, material);
            scene.add(globe);

            // Inner glow sphere
            const innerGeometry = new THREE.SphereGeometry(0.98, 16, 12);
            const innerMaterial = new THREE.MeshBasicMaterial({
                color: 0x003300,
                wireframe: true,
                transparent: true,
                opacity: 0.15
            });
            const innerSphere = new THREE.Mesh(innerGeometry, innerMaterial);
            globe.add(innerSphere);

            // Latitude lines (more visible)
            for (let i = -60; i <= 60; i += 30) {
                const latRadius = Math.cos(i * Math.PI / 180);
                const latY = Math.sin(i * Math.PI / 180);
                const latGeometry = new THREE.RingGeometry(latRadius - 0.002, latRadius + 0.002, 64);
                const latMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.5
                });
                const latRing = new THREE.Mesh(latGeometry, latMaterial);
                latRing.position.y = latY;
                latRing.rotation.x = Math.PI / 2;
                globe.add(latRing);
            }

            // Equator (brighter)
            const equatorGeometry = new THREE.RingGeometry(0.998, 1.002, 64);
            const equatorMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            const equator = new THREE.Mesh(equatorGeometry, equatorMaterial);
            equator.rotation.x = Math.PI / 2;
            globe.add(equator);

            // Prime meridian
            const meridianGeometry = new THREE.TorusGeometry(1, 0.003, 8, 64);
            const meridianMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.5
            });
            const meridian = new THREE.Mesh(meridianGeometry, meridianMaterial);
            globe.add(meridian);

            // Add some "ASCII" dots pattern on the surface
            const dotsGeometry = new THREE.BufferGeometry();
            const dotPositions = [];
            for (let i = 0; i < 500; i++) {
                const phi = Math.acos(-1 + (2 * i) / 500);
                const theta = Math.sqrt(500 * Math.PI) * phi;
                const x = Math.cos(theta) * Math.sin(phi);
                const y = Math.sin(theta) * Math.sin(phi);
                const z = Math.cos(phi);
                dotPositions.push(x * 1.01, y * 1.01, z * 1.01);
            }
            dotsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dotPositions, 3));
            const dotsMaterial = new THREE.PointsMaterial({
                color: 0x00ff00,
                size: 0.015,
                transparent: true,
                opacity: 0.4
            });
            const dots = new THREE.Points(dotsGeometry, dotsMaterial);
            globe.add(dots);
        }

        function latLngToVector3(lat, lng, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lng + 180) * (Math.PI / 180);
            const x = -radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);
            return new THREE.Vector3(x, y, z);
        }

        function createPlaylistPoints() {
            playlists.forEach((playlist, index) => {
                const position = latLngToVector3(playlist.lat, playlist.lng, 1.02);

                // Glowing point (smaller for many playlists)
                const pointGeometry = new THREE.SphereGeometry(0.012, 12, 12);
                const pointMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.9
                });
                const point = new THREE.Mesh(pointGeometry, pointMaterial);
                point.position.copy(position);
                point.userData = { playlist, index };

                globe.add(point);
                points.push({ point, playlist });
            });
        }

        function addEventListeners() {
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mouseleave', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);
            renderer.domElement.addEventListener('click', onClick);
            renderer.domElement.addEventListener('dblclick', onDoubleClick);
            window.addEventListener('resize', onWindowResize);
            document.getElementById('close-panel').addEventListener('click', closePanel);
        }

        function onMouseDown(event) {
            isDragging = true;
            autoRotate = false;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Check for hover on points
            raycaster.setFromCamera(mouse, camera);
            const pointMeshes = points.map(p => p.point);
            const intersects = raycaster.intersectObjects(pointMeshes);

            if (intersects.length > 0) {
                // Sort by distance and get the closest one
                intersects.sort((a, b) => a.distance - b.distance);
                const playlist = intersects[0].object.userData.playlist;
                tooltip.style.display = 'block';
                tooltip.style.left = event.clientX + 15 + 'px';
                tooltip.style.top = event.clientY + 15 + 'px';
                tooltip.innerHTML = `► ${playlist.name}<br><span style="opacity:0.6">${playlist.location}</span>`;
                renderer.domElement.style.cursor = 'pointer';
            } else {
                tooltip.style.display = 'none';
                renderer.domElement.style.cursor = isDragging ? 'grabbing' : 'grab';
            }

            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                rotationVelocity.x = deltaY * 0.005;
                rotationVelocity.y = deltaX * 0.005;

                globe.rotation.x += rotationVelocity.x;
                globe.rotation.y += rotationVelocity.y;

                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }

        function onMouseUp() {
            isDragging = false;
            renderer.domElement.style.cursor = 'grab';
        }

        function onWheel(event) {
            event.preventDefault();
            camera.position.z += event.deltaY * 0.001;
            camera.position.z = Math.max(1.5, Math.min(5, camera.position.z));
        }

        function onClick(event) {
            // Stop rotation on any click
            autoRotate = false;
            rotationVelocity = { x: 0, y: 0 };

            raycaster.setFromCamera(mouse, camera);
            const pointMeshes = points.map(p => p.point);
            const intersects = raycaster.intersectObjects(pointMeshes);

            if (intersects.length > 0) {
                // Sort by distance and get the closest one
                intersects.sort((a, b) => a.distance - b.distance);
                const playlist = intersects[0].object.userData.playlist;
                openPlaylist(playlist);
            }
        }

        function onDoubleClick(event) {
            // Resume rotation on double click
            autoRotate = true;
        }

        function openPlaylist(playlist) {
            panelTitle.textContent = playlist.name;
            panelLocation.textContent = playlist.location;
            spotifyEmbed.innerHTML = `
                <iframe
                    style="border-radius:12px"
                    src="https://open.spotify.com/embed/playlist/${playlist.spotifyId}?utm_source=generator&theme=0"
                    width="100%"
                    height="100%"
                    frameBorder="0"
                    allowfullscreen=""
                    allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"
                    loading="lazy">
                </iframe>
            `;
            panel.classList.add('open');
        }

        function closePanel() {
            panel.classList.remove('open');
            spotifyEmbed.innerHTML = '';
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Auto rotation when not dragging
            if (autoRotate) {
                globe.rotation.y += 0.0005;
            } else {
                // Momentum after dragging
                if (!isDragging) {
                    rotationVelocity.x *= 0.95;
                    rotationVelocity.y *= 0.95;
                    globe.rotation.x += rotationVelocity.x;
                    globe.rotation.y += rotationVelocity.y;
                }
            }

            renderer.render(scene, camera);
        }

        // Start
        init();
    </script>
</body>
</html>
