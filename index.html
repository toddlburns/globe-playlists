<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crambe Repetita</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #00ff00;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        /* Scanline overlay for retro effect */
        #scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            z-index: 10;
        }

        /* CRT screen curve effect */
        #crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(
                ellipse at center,
                transparent 0%,
                transparent 70%,
                rgba(0, 0, 0, 0.4) 100%
            );
            z-index: 11;
        }

        #title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 8px;
            text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00;
            z-index: 20;
        }

        #about-link {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            opacity: 0.6;
            z-index: 20;
            text-align: center;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        #about-link:hover {
            opacity: 1;
            text-shadow: 0 0 10px #00ff00;
        }

        /* About modal */
        #about-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 200;
            display: none;
            justify-content: center;
            align-items: center;
        }

        #about-overlay.open {
            display: flex;
        }

        #about-box {
            background: rgba(0, 10, 0, 0.95);
            border: 2px solid #00ff00;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            position: relative;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.2);
        }

        #about-box h2 {
            font-size: 20px;
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 25px;
            text-shadow: 0 0 10px #00ff00;
        }

        #about-content {
            font-size: 14px;
            line-height: 1.8;
            min-height: 150px;
        }

        #about-cursor {
            display: inline-block;
            width: 10px;
            height: 16px;
            background: #00ff00;
            margin-left: 2px;
            animation: blink 0.7s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        #close-about {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: 1px solid #00ff00;
            color: #00ff00;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 16px;
        }

        #close-about:hover {
            background: #00ff00;
            color: #0a0a0a;
        }

        #about-content a {
            color: #00ff00;
            text-decoration: none;
        }

        #about-content a:hover {
            text-shadow: 0 0 10px #00ff00;
        }

        /* Playlist panel */
        #playlist-panel {
            position: fixed;
            right: -420px;
            top: 0;
            width: 400px;
            height: 100%;
            background: rgba(0, 10, 0, 0.95);
            border-left: 2px solid #00ff00;
            transition: right 0.3s ease;
            z-index: 100;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        #playlist-panel.open {
            right: 0;
        }

        #playlist-panel h2 {
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ff00;
            font-size: 18px;
        }

        #playlist-panel .location {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 20px;
        }

        #close-panel {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: 1px solid #00ff00;
            color: #00ff00;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 16px;
        }

        #close-panel:hover {
            background: #00ff00;
            color: #0a0a0a;
        }

        #spotify-embed {
            flex: 1;
            border: 1px solid #00ff00;
            border-radius: 8px;
            overflow: hidden;
        }

        #spotify-embed iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Tooltip for hover */
        #tooltip {
            position: fixed;
            background: rgba(0, 20, 0, 0.9);
            border: 1px solid #00ff00;
            padding: 8px 12px;
            font-size: 12px;
            pointer-events: none;
            z-index: 50;
            display: none;
            text-shadow: 0 0 5px #00ff00;
        }

        /* Glow effect for points */
        .point-label {
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }

        /* Search container */
        #search-container {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            width: 300px;
        }

        #search-input {
            width: 100%;
            padding: 10px 15px;
            background: rgba(0, 10, 0, 0.8);
            border: 1px solid #00ff00;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #ff1493;
            text-shadow: 0 0 8px #ff1493;
            outline: none;
            caret-color: #ff1493;
        }

        #search-input::placeholder {
            color: #00ff00;
            opacity: 0.5;
            text-shadow: none;
        }

        #search-input:focus {
            border-color: #ff1493;
            box-shadow: 0 0 10px rgba(255, 20, 147, 0.3);
        }

        #search-dropdown {
            position: absolute;
            bottom: 100%;
            left: 0;
            width: 100%;
            max-height: 300px;
            overflow-y: auto;
            background: rgba(0, 10, 0, 0.95);
            border: 1px solid #00ff00;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            display: none;
        }

        #search-dropdown.open {
            display: block;
        }

        .search-option {
            padding: 10px 15px;
            cursor: pointer;
            font-size: 13px;
            color: #b06080;
            border-bottom: 1px solid rgba(255, 20, 147, 0.1);
            transition: background 0.15s ease;
        }

        .search-option:hover {
            background: rgba(255, 20, 147, 0.1);
            color: #d080a0;
        }

        .search-option .location-hint {
            font-size: 11px;
            color: #804060;
            margin-top: 2px;
        }

        #search-dropdown::-webkit-scrollbar {
            width: 6px;
        }

        #search-dropdown::-webkit-scrollbar-track {
            background: rgba(0, 10, 0, 0.5);
        }

        #search-dropdown::-webkit-scrollbar-thumb {
            background: #00ff00;
            border-radius: 3px;
        }

        /* Intro animation */
        #intro-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.85);
            z-index: 500;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 1;
            transition: opacity 0.8s ease;
            pointer-events: all;
        }

        #intro-overlay.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        #intro-overlay.hidden {
            display: none;
        }

        #intro-text {
            font-family: 'Courier New', monospace;
            font-size: 48px;
            font-weight: bold;
            letter-spacing: 8px;
            text-transform: uppercase;
            color: #00ff00;
            text-shadow:
                0 0 5px #00ff00,
                0 0 10px #00ff00,
                0 0 20px #00ff00,
                0 0 40px #00ff00,
                0 0 80px #003300;
            opacity: 0;
        }

        @keyframes neon-pulse {
            0% {
                text-shadow:
                    0 0 5px #00ff00,
                    0 0 10px #00ff00,
                    0 0 20px #00ff00,
                    0 0 40px #00ff00,
                    0 0 80px #003300;
            }
            100% {
                text-shadow:
                    0 0 10px #00ff00,
                    0 0 20px #00ff00,
                    0 0 40px #00ff00,
                    0 0 60px #00ff00,
                    0 0 100px #003300;
            }
        }

        @keyframes flicker-in {
            0% { opacity: 0; }
            10% { opacity: 0.6; }
            20% { opacity: 0.2; }
            30% { opacity: 0.8; }
            40% { opacity: 0.3; }
            50% { opacity: 0.9; }
            60% { opacity: 0.5; }
            70% { opacity: 1; }
            80% { opacity: 0.7; }
            90% { opacity: 0.95; }
            100% { opacity: 1; }
        }

        @keyframes flicker-out {
            0% { opacity: 1; }
            5% { opacity: 0.9; }
            10% { opacity: 1; }
            15% { opacity: 0.7; }
            20% { opacity: 0.9; }
            30% { opacity: 0.4; }
            35% { opacity: 0.7; }
            40% { opacity: 0.3; }
            50% { opacity: 0.6; }
            55% { opacity: 0.2; }
            60% { opacity: 0.5; }
            70% { opacity: 0.1; }
            75% { opacity: 0.3; }
            80% { opacity: 0.05; }
            85% { opacity: 0.2; }
            90% { opacity: 0.02; }
            95% { opacity: 0.1; }
            100% { opacity: 0; }
        }

        #intro-text.flicker-in {
            animation: flicker-in 0.8s ease forwards, neon-pulse 2s ease-in-out infinite alternate;
        }

        #intro-text.flicker-out {
            animation: flicker-out 2s ease forwards;
        }

        @keyframes tv-on {
            0% {
                transform: scale(1, 0.02);
                filter: brightness(10);
            }
            50% {
                transform: scale(1, 0.02);
                filter: brightness(5);
            }
            70% {
                transform: scale(1, 1);
                filter: brightness(2);
            }
            100% {
                transform: scale(1, 1);
                filter: brightness(1);
            }
        }

        #intro-overlay.tv-on {
            animation: tv-on 0.6s ease-out forwards;
        }
    </style>
</head>
<body>
    <div id="intro-overlay">
        <div id="intro-text"></div>
    </div>
    <div id="container"></div>
    <div id="scanlines"></div>
    <div id="crt-overlay"></div>
    <div id="title">[ Crambe Repetita ]</div>
    <div id="search-container">
        <input type="text" id="search-input" placeholder="Search playlists..." autocomplete="off">
        <div id="search-dropdown"></div>
    </div>
    <div id="about-link">[ About ]</div>
    <div id="tooltip"></div>

    <div id="about-overlay">
        <div id="about-box">
            <button id="close-about">×</button>
            <h2 id="about-title"></h2>
            <div id="about-content"><span id="about-cursor"></span></div>
        </div>
    </div>

    <div id="playlist-panel">
        <button id="close-panel">×</button>
        <h2 id="panel-title">Playlist Name</h2>
        <div class="location" id="panel-location">Location</div>
        <div id="spotify-embed"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="playlists-data.js"></script>
    <script>
        let scene, camera, renderer, globe, points = [];
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationVelocity = { x: 0, y: 0 };
        let autoRotate = true;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const container = document.getElementById('container');
        const tooltip = document.getElementById('tooltip');
        const panel = document.getElementById('playlist-panel');
        const panelTitle = document.getElementById('panel-title');
        const panelLocation = document.getElementById('panel-location');
        const spotifyEmbed = document.getElementById('spotify-embed');

        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 2.5;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x0a0a0a);
            container.appendChild(renderer.domElement);

            createGlobe();
            createPlaylistPoints();
            addEventListeners();
            animate();
        }

        function createGlobe() {
            // Main wireframe sphere
            const geometry = new THREE.SphereGeometry(1, 32, 24);
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            globe = new THREE.Mesh(geometry, material);
            scene.add(globe);

            // Inner glow sphere
            const innerGeometry = new THREE.SphereGeometry(0.98, 16, 12);
            const innerMaterial = new THREE.MeshBasicMaterial({
                color: 0x003300,
                wireframe: true,
                transparent: true,
                opacity: 0.15
            });
            const innerSphere = new THREE.Mesh(innerGeometry, innerMaterial);
            globe.add(innerSphere);

            // Latitude lines (more visible)
            for (let i = -60; i <= 60; i += 30) {
                const latRadius = Math.cos(i * Math.PI / 180);
                const latY = Math.sin(i * Math.PI / 180);
                const latGeometry = new THREE.RingGeometry(latRadius - 0.002, latRadius + 0.002, 64);
                const latMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.5
                });
                const latRing = new THREE.Mesh(latGeometry, latMaterial);
                latRing.position.y = latY;
                latRing.rotation.x = Math.PI / 2;
                globe.add(latRing);
            }

            // Equator (brighter)
            const equatorGeometry = new THREE.RingGeometry(0.998, 1.002, 64);
            const equatorMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            const equator = new THREE.Mesh(equatorGeometry, equatorMaterial);
            equator.rotation.x = Math.PI / 2;
            globe.add(equator);

            // Prime meridian
            const meridianGeometry = new THREE.TorusGeometry(1, 0.003, 8, 64);
            const meridianMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.5
            });
            const meridian = new THREE.Mesh(meridianGeometry, meridianMaterial);
            globe.add(meridian);

            // Add some "ASCII" dots pattern on the surface
            const dotsGeometry = new THREE.BufferGeometry();
            const dotPositions = [];
            for (let i = 0; i < 500; i++) {
                const phi = Math.acos(-1 + (2 * i) / 500);
                const theta = Math.sqrt(500 * Math.PI) * phi;
                const x = Math.cos(theta) * Math.sin(phi);
                const y = Math.sin(theta) * Math.sin(phi);
                const z = Math.cos(phi);
                dotPositions.push(x * 1.01, y * 1.01, z * 1.01);
            }
            dotsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dotPositions, 3));
            const dotsMaterial = new THREE.PointsMaterial({
                color: 0x00ff00,
                size: 0.015,
                transparent: true,
                opacity: 0.4
            });
            const dots = new THREE.Points(dotsGeometry, dotsMaterial);
            globe.add(dots);
        }

        function latLngToVector3(lat, lng, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lng + 180) * (Math.PI / 180);
            const x = -radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);
            return new THREE.Vector3(x, y, z);
        }

        function createPlaylistPoints() {
            playlists.forEach((playlist, index) => {
                const position = latLngToVector3(playlist.lat, playlist.lng, 1.02);

                // Glowing point (smaller for many playlists)
                const pointGeometry = new THREE.SphereGeometry(0.012, 12, 12);
                const pointMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.9
                });
                const point = new THREE.Mesh(pointGeometry, pointMaterial);
                point.position.copy(position);
                point.userData = { playlist, index };

                globe.add(point);
                points.push({ point, playlist });
            });
        }

        function addEventListeners() {
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mouseleave', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);
            renderer.domElement.addEventListener('click', onClick);
            renderer.domElement.addEventListener('dblclick', onDoubleClick);
            window.addEventListener('resize', onWindowResize);
            document.getElementById('close-panel').addEventListener('click', closePanel);
        }

        function onMouseDown(event) {
            isDragging = true;
            autoRotate = false;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Check for hover on points
            raycaster.setFromCamera(mouse, camera);
            const pointMeshes = points.map(p => p.point);
            const intersects = raycaster.intersectObjects(pointMeshes);

            // Only consider points on the front side of the globe
            const globeDistance = camera.position.z;
            const frontIntersects = intersects.filter(i => i.distance < globeDistance);

            if (frontIntersects.length > 0) {
                // Sort by distance and get the closest one
                frontIntersects.sort((a, b) => a.distance - b.distance);
                const playlist = frontIntersects[0].object.userData.playlist;
                tooltip.style.display = 'block';
                tooltip.style.left = event.clientX + 15 + 'px';
                tooltip.style.top = event.clientY + 15 + 'px';
                tooltip.innerHTML = `► ${playlist.name}<br><span style="opacity:0.6">${playlist.location}</span>`;
                renderer.domElement.style.cursor = 'pointer';
            } else {
                tooltip.style.display = 'none';
                renderer.domElement.style.cursor = isDragging ? 'grabbing' : 'grab';
            }

            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                rotationVelocity.x = deltaY * 0.005;
                rotationVelocity.y = deltaX * 0.005;

                globe.rotation.x += rotationVelocity.x;
                globe.rotation.y += rotationVelocity.y;

                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }

        function onMouseUp() {
            isDragging = false;
            renderer.domElement.style.cursor = 'grab';
        }

        function onWheel(event) {
            event.preventDefault();
            camera.position.z += event.deltaY * 0.001;
            camera.position.z = Math.max(1.5, Math.min(5, camera.position.z));
        }

        function onClick(event) {
            // Stop rotation on any click
            autoRotate = false;
            rotationVelocity = { x: 0, y: 0 };

            raycaster.setFromCamera(mouse, camera);
            const pointMeshes = points.map(p => p.point);
            const intersects = raycaster.intersectObjects(pointMeshes);

            if (intersects.length > 0) {
                // Sort by distance and get the closest one
                intersects.sort((a, b) => a.distance - b.distance);

                // Only select points on the front side of the globe (closer than globe center)
                const globeDistance = camera.position.z;
                const closest = intersects.find(i => i.distance < globeDistance);

                if (closest) {
                    const playlist = closest.object.userData.playlist;
                    openPlaylist(playlist);
                }
            }
        }

        function onDoubleClick(event) {
            // Resume rotation on double click
            autoRotate = true;
        }

        function openPlaylist(playlist) {
            panelTitle.textContent = playlist.name;
            panelLocation.textContent = playlist.location;
            spotifyEmbed.innerHTML = `
                <iframe
                    style="border-radius:12px"
                    src="https://open.spotify.com/embed/playlist/${playlist.spotifyId}?utm_source=generator&theme=0"
                    width="100%"
                    height="100%"
                    frameBorder="0"
                    allowfullscreen=""
                    allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"
                    loading="lazy">
                </iframe>
            `;
            panel.classList.add('open');
        }

        function closePanel() {
            panel.classList.remove('open');
            spotifyEmbed.innerHTML = '';
        }

        // Search functionality
        const searchInput = document.getElementById('search-input');
        const searchDropdown = document.getElementById('search-dropdown');
        let isSpinning = false;

        searchInput.addEventListener('input', function() {
            const query = this.value.toLowerCase().trim();

            if (query.length < 1) {
                searchDropdown.classList.remove('open');
                return;
            }

            const matches = playlists.filter(p =>
                p.name.toLowerCase().includes(query) ||
                p.location.toLowerCase().includes(query)
            ).slice(0, 10);

            if (matches.length > 0) {
                searchDropdown.innerHTML = matches.map((p, i) => `
                    <div class="search-option" data-index="${playlists.indexOf(p)}">
                        ${p.name}
                        <div class="location-hint">${p.location}</div>
                    </div>
                `).join('');
                searchDropdown.classList.add('open');
            } else {
                searchDropdown.classList.remove('open');
            }
        });

        searchInput.addEventListener('focus', function() {
            if (this.value.length >= 1) {
                searchInput.dispatchEvent(new Event('input'));
            }
        });

        document.addEventListener('click', function(e) {
            if (!e.target.closest('#search-container')) {
                searchDropdown.classList.remove('open');
            }
        });

        searchDropdown.addEventListener('click', function(e) {
            const option = e.target.closest('.search-option');
            if (option) {
                const index = parseInt(option.dataset.index);
                const playlist = playlists[index];
                searchInput.value = '';
                searchDropdown.classList.remove('open');
                spinToPlaylist(playlist);
            }
        });

        function spinToPlaylist(playlist) {
            if (isSpinning) return;
            isSpinning = true;
            autoRotate = false;
            rotationVelocity = { x: 0, y: 0 };

            const targetPosition = latLngToVector3(playlist.lat, playlist.lng, 1.02);

            // Calculate target rotation to face the point
            const targetLng = playlist.lng;
            const targetLat = playlist.lat;

            // Target Y rotation (longitude) - add 180 to face the point
            const targetRotY = -((targetLng + 180) * Math.PI / 180) + Math.PI;
            // Target X rotation (latitude)
            const targetRotX = (targetLat * Math.PI / 180);

            // Current rotation
            const startRotX = globe.rotation.x;
            const startRotY = globe.rotation.y;

            // Normalize current Y rotation
            let normalizedStartY = startRotY % (2 * Math.PI);

            // Calculate the shortest path for Y rotation
            let deltaY = targetRotY - normalizedStartY;

            // Add extra spins for dramatic effect (2 full rotations + shortest path)
            const extraSpins = 2 * 2 * Math.PI;
            if (deltaY > 0) {
                deltaY += extraSpins;
            } else {
                deltaY -= extraSpins;
            }

            const finalRotY = startRotY + deltaY;
            const duration = 1500; // 1.5 seconds
            const startTime = Date.now();

            function animateSpin() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Easing function: easeOutExpo for fast start, smooth end
                const eased = progress === 1 ? 1 : 1 - Math.pow(2, -10 * progress);

                globe.rotation.x = startRotX + (targetRotX - startRotX) * eased;
                globe.rotation.y = startRotY + (finalRotY - startRotY) * eased;

                if (progress < 1) {
                    requestAnimationFrame(animateSpin);
                } else {
                    isSpinning = false;
                    openPlaylist(playlist);
                }
            }

            animateSpin();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Auto rotation when not dragging
            if (autoRotate) {
                globe.rotation.y += 0.0005;
            } else {
                // Momentum after dragging
                if (!isDragging) {
                    rotationVelocity.x *= 0.95;
                    rotationVelocity.y *= 0.95;
                    globe.rotation.x += rotationVelocity.x;
                    globe.rotation.y += rotationVelocity.y;
                }
            }

            renderer.render(scene, camera);
        }

        // About page typewriter effect
        const aboutLink = document.getElementById('about-link');
        const aboutOverlay = document.getElementById('about-overlay');
        const aboutTitle = document.getElementById('about-title');
        const aboutContent = document.getElementById('about-content');
        const closeAbout = document.getElementById('close-about');

        const aboutTitleText = 'crambe repetita';
        const aboutBodyText = `Hi! Thanks for coming by my playlist website. My name is Todd L. Burns and I love music! If you're anything like me, you probably like to dig for music. To find that next great song, album, mix, or whatever. Well, I've created this fun little website to share some of my own finds from around the world. I hope you enjoy my music taste just as much as I do! If you ever want to chat about music, you can reach me at <a href="mailto:todd.burns@gmail.com">todd.burns@gmail.com</a>. Have a blessed day!`;

        let typewriterTimeout;
        let isTyping = false;

        function typeWriter(element, text, index, callback) {
            if (index < text.length) {
                // Handle HTML tags
                if (text[index] === '<') {
                    const tagEnd = text.indexOf('>', index);
                    if (tagEnd !== -1) {
                        const closingTagStart = text.indexOf('</', tagEnd);
                        const closingTagEnd = text.indexOf('>', closingTagStart);
                        if (closingTagStart !== -1 && closingTagEnd !== -1) {
                            const fullTag = text.substring(index, closingTagEnd + 1);
                            element.innerHTML = text.substring(0, closingTagEnd + 1) + '<span id="about-cursor"></span>';
                            typewriterTimeout = setTimeout(() => typeWriter(element, text, closingTagEnd + 1, callback), 30);
                            return;
                        }
                    }
                }

                element.innerHTML = text.substring(0, index + 1) + '<span id="about-cursor"></span>';

                // Check if we just typed a sentence-ending punctuation
                const char = text[index];
                const nextChar = text[index + 1];
                const isSentenceEnd = (char === '.' || char === '!' || char === '?') && nextChar === ' ';

                let delay = 25; // Fast typing
                if (isSentenceEnd) {
                    delay = 1200; // Pause at end of sentence
                }

                typewriterTimeout = setTimeout(() => typeWriter(element, text, index + 1, callback), delay);
            } else {
                element.innerHTML = text + '<span id="about-cursor"></span>';
                if (callback) callback();
            }
        }

        function startAboutAnimation() {
            aboutTitle.textContent = '';
            aboutContent.innerHTML = '<span id="about-cursor"></span>';
            isTyping = true;

            // Type title first
            let titleIndex = 0;
            function typeTitle() {
                if (titleIndex < aboutTitleText.length) {
                    aboutTitle.textContent = aboutTitleText.substring(0, titleIndex + 1);
                    titleIndex++;
                    typewriterTimeout = setTimeout(typeTitle, 50);
                } else {
                    // Then type body
                    setTimeout(() => {
                        typeWriter(aboutContent, aboutBodyText, 0, () => {
                            isTyping = false;
                        });
                    }, 500);
                }
            }
            typeTitle();
        }

        function openAbout() {
            aboutOverlay.classList.add('open');
            startAboutAnimation();
        }

        function closeAboutPanel() {
            aboutOverlay.classList.remove('open');
            clearTimeout(typewriterTimeout);
            isTyping = false;
        }

        aboutLink.addEventListener('click', openAbout);
        closeAbout.addEventListener('click', closeAboutPanel);
        aboutOverlay.addEventListener('click', function(e) {
            if (e.target === aboutOverlay) {
                closeAboutPanel();
            }
        });

        // Intro animation
        const introOverlay = document.getElementById('intro-overlay');
        const introText = document.getElementById('intro-text');
        const introTitle = 'crambe repetita';

        function playIntro() {
            // TV turning on effect
            setTimeout(() => {
                introOverlay.classList.add('tv-on');
            }, 100);

            // Start typing after TV on effect
            setTimeout(() => {
                typeIntroText(0);
            }, 800);
        }

        function typeIntroText(index) {
            if (index <= introTitle.length) {
                introText.textContent = introTitle.substring(0, index);
                if (index === 1) {
                    introText.classList.add('flicker-in');
                }
                setTimeout(() => typeIntroText(index + 1), 180);
            } else {
                // Text fully typed, wait then flicker out
                setTimeout(() => {
                    introText.classList.remove('flicker-in');
                    introText.classList.add('flicker-out');

                    // Fade out overlay after text flickers out
                    setTimeout(() => {
                        introOverlay.classList.add('fade-out');

                        // Remove from DOM after fade
                        setTimeout(() => {
                            introOverlay.classList.add('hidden');
                        }, 800);
                    }, 2000);
                }, 1500);
            }
        }

        // Start intro, then init
        playIntro();
        init();
    </script>
</body>
</html>
